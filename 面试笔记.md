---
title:  面试笔记
date: 2016-04-11 19:33:47
tags: 学习
---

### 程序员面试笔记。
<!-- more -->

## 一. J2EE基础

-  九种基本数据类型的大小，以及他们的封装类。

|基本类型|大小（字节）|默认值|封装类|
|:---:|:---:|:---:|:---:|
|byte|1|0|Byte|
|short|2|0|Short|
|int|4|0|Integer|
|long|8|0L|Long|
|float|**4**|0.0f|Float|
|double|8|0.0d|Double|
|boolean|1|false|Boolean|
|char|2|null|Character|
|void|||Void|


- equals与==的区别。
```
    1. ==指引用是否相同,equals()指的是值是否相同
    2. ==是指对内存地址进行比较,equals()是对字符串的内容进行比较
    3. ==是判断两个变量或实例是不是指向同一个内存空间 ,equals是判断两个变量或实例所指向的内存空间的值是不是相同
    4. 使用==比较原生类型如：boolean、int、char等等，使用equals()比较对象。因为原生类型不是对象，没有方法。
```
-  Switch能否用string做参数？
```
在java1.7之前，可以放int,byte,char。因为它们可以自动类型转换为int。java1.7可以使用string类型。
```    
- Object有哪些公用方法
```
1. clone

保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。

2. getClass

final方法，获得运行时类型。

3. toString

该方法用得比较多，一般子类都有覆盖。

4. finalize

该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。

5．equals

该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。

6．hashCode

该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。

一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。

如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。

7. wait

wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。

调用该方法后当前线程进入睡眠状态，直到以下事件发生。

（1）其他线程调用了该对象的notify方法。

（2）其他线程调用了该对象的notifyAll方法。

（3）其他线程调用了interrupt中断该线程。

（4）时间间隔到了。

此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。

8. notify

该方法唤醒在该对象上等待的某个线程。

9. notifyAll

该方法唤醒在该对象上等待的所有线程。
```
- Java的四种引用，强弱软虚，用到的场景。

```
1. 强引用
    Object obj = new Object();
    这里的obj引用便是一个强引用。垃圾回收器绝不会回收它。

2. 软引用（SoftReference）
    如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
3. 弱引用（WeakReference）
    一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回 收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
    4. 虚引用（PhantomReference）
```
- Hashcode的作用。
```
1、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；

2、如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；

3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；

4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object)方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。

再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。也就是说，我们先通过hashcode来判断某个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过equals来在这个桶里找到我们要的类。那么。重写了equals()，为什么还要重写hashCode()呢？想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊  
```
- ArrayList、LinkedList、Vector的区别。
![](http://ww1.sinaimg.cn/mw690/5a65f7d1gw1f2rp9prh75j206y07g3yb.jpg)
```
一、同步性
ArrayList,LinkedList是不同步的，而Vestor是的。

二、数据增长
Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。

三、检索、插入、删除对象的效率
但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。LinkedList中，在插入、删除集合中任何位置的元素所花费的时间都是一样的—O(1)，但它在索引一个元素的时候比较慢，为O(i),其中i是索引的位置。

所以，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList。
```
- String、StringBuffer与StringBuilder的区别。
```   
String 字符串常量,不可变的对象
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）

```
-  Map、Set、List、Queue、Stack的特点与用法。
```
Collection是对象集合，Collection 有两个子接口List和Set
List 可以通过下标(1,2..)来取得值，值可以重复
而Set只能通过游标来取值，并且值是不能重复的
ArrayList，Vector，LinkedList是List的实现类
ArrayList是线程不安全的，Vector 是线程安全的，这两个类底层都是由数组实现的
LinkedList是线程不安全的，底层是由链表实现的   
```
- HashMap和HashTable的区别。
```
Hashtable的方法是同步的，HashMap则是非同步的，所以在多线程场合要手动同步HashMap，这个区别就像Vector和ArrayList一样。

Hashtable不允许null值（key和value都不可以），HashMap允许null值（key和value都可以）。

Hashtable比HashMap多一个elements方法用于遍历。

Hashtable使用Enumeration，HashMap使用Iterator。

哈希值的使用不同，Hashtable直接使用对象的hashCode，而HashMap重新计算hash值，而且用与代替求模。

Hashtable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。
```
- HashMap和ConcurrentHashMap的区别，HashMap的底层源码。

> ConcurrentHashMap：在hashMap的基础上，ConcurrentHashMap将数据分为多个segment，默认16个（concurrency level），然后每次操作对一个segment加锁，避免多线程锁的几率，提高并发效率。

![](http://images2015.cnblogs.com/blog/679904/201510/679904-20151025192734520-1277367181.png)

> HashMap的底层主要是基于数组和链表来实现的。HashMap底层是通过链表来解决hash冲突的。HashMap底层就是一个数组结构，数组中存放的是一个Entry对象。HashMap其实就是一个Entry数组，Entry对象中包含了键和值，其中next也是一个Entry对象，它就是用来处理hash冲突的，形成一个链表。

- Collection包结构，与Collections的区别。
> Collection是集合类的上级***接口***，子接口主要有Set 和List、Map。
Collections是针对集合类的一个***帮助类***，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

- try catch finally，try里有return，finally还执行么？
> 会。一般先执行finally，在return。

- ava面向对象的三个特征与含义。
> 面向对象的三个基本特征是：封装、继承、多态。
1. 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作
2. 继承，它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
3. 允许将子类类型的指针赋值给父类类型的指针。Override和Overload

- Override和Overload的含义去区别。
> 二者完全是两个概念。重写Overriding是**父类与子类**之间多态性的一种表现，重载Overloading是**一个类**中多态性的一种表现。
- Interface与abstract类的区别。
-
> 1. 抽象类不能被实例化，只能被用作子类的超类，接口是抽象方法的集合
2. 单继承，实现多接口

- Static class 与non static class的区别。

> 1. 静态内部类的作用：只是为了降低包的深度，方便类的使用，静态内部类适用于包含类当中，但又不依赖与外在的类，不用使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。在创建静态内部类的时候，**不需要外部类对象的引用**。
2. 非静态内部类有一个很大的优点：可以自由使用外部类的所有变量和方法，对**外部类对象有引用**

- 实现多线程的两种方法。

>  继承Thread类。 实现Runable接口
后者优点：
1. 适合多个相同代码的线程去处理同一个资源的情况
   2. 可以避免由于java的单继承特性带来的局限
   3. 增强了程序的健壮性，代码能够被多个线程共享，代码与数据时独立的
   4. implement Runnable是面向接口，**扩展性**等方面比extends Thread好。

- 线程同步的方法。

> sychronized，lock，reentrantLock，volatile
1. sychronized同步方法，代码块（同步是一种高开销的操作，因此应该**尽量减少同步的内容**。通常没有必要同步整个方法，**使用synchronized**代码块同步关键代码即可。）
2. volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新
3. 重入锁reentrantLock，要注意及时释放锁
4. 使用局部变量实现线程同步ThreadLocal

- 锁的等级：方法锁（对象锁）、类锁。

- 写出生产者消费者模式。（理解多线程，和同步的使用）

- ThreadLocal的设计理念与作用。
> Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。

-  Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等。

> 阻塞队列 BlockingQueue。

- wait()和sleep()的区别。

> 1. sleep()睡眠时，保持对象锁，仍然占有该锁；
2. 而wait()睡眠时，释放对象锁。
3. sleep是Thread类的方法,wait是Object类中定义的方法
4. 两者的共同点：都会阻塞当前线程。
